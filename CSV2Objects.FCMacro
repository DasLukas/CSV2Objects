# -*- coding: utf-8 -*-
"""
CSV2Objects

Macro CSV2Objects.FCMacro
Author: Lukas Waschul
Version: 0.1.0
Date: 2025-01-04
FreeCAD version: 0.21 or later
License: MIT
Website: https://github.com/DasLukas/CSV2Objects

Description:
    CSV2Objects is a macro that generates large batches of 3D text objects
    from CSV files. It maps CSV columns to horizontal sketch guide lines,
    creates ShapeStrings on the sketch plane, extrudes them, and optionally
    fuses them with a target solid. It supports batch export to STL, 3MF,
    and STEP, and restores the document state after a final export.
"""

import FreeCAD as App
import FreeCADGui as Gui
import Part
import Draft
import Mesh
import ImportGui
import csv
import os
import sys
import glob

try:
    from PySide2 import QtCore, QtGui, QtWidgets
except ImportError:
    from PySide import QtCore, QtGui, QtGui as QtWidgets


MAX_PATH_LEN = 240  # conservative upper bound for file path lengths


class CSV2ObjectsTaskPanel:
    """
    Task panel to place CSV-driven text on sketch guide lines and export geometry.
    - Text from CSV onto guide lines
    - ShapeString + extrusion
    - Live preview (first CSV row)
    - Optional boolean fuse with a target body (per CSV row)
    - STL/3MF/STEP export into a subfolder next to the FCStd file
    - Restore the document state after a final export
    """

    def __init__(self):
        self.doc = App.ActiveDocument
        if self.doc is None:
            raise RuntimeError("No active document is open.")

        # Preview objects (ShapeStrings + Extrudes) of the live preview
        self.preview_objects = []
        # (adoption handled on OK)

        # ---------- Main widget ----------
        self.form = QtWidgets.QWidget()
        self.form.setWindowTitle("CSV text on guide lines")

        main_layout = QtWidgets.QVBoxLayout(self.form)

        # -------------------------------------------------
        # CSV settings
        # -------------------------------------------------
        csv_group = QtWidgets.QGroupBox("CSV settings")
        csv_layout = QtWidgets.QGridLayout(csv_group)

        self.csv_path_edit = QtWidgets.QLineEdit()
        self.csv_browse_btn = QtWidgets.QPushButton("Browse CSV…")

        csv_layout.addWidget(QtWidgets.QLabel("CSV file:"), 0, 0)
        csv_layout.addWidget(self.csv_path_edit, 0, 1)
        csv_layout.addWidget(self.csv_browse_btn, 0, 2)

        self.encoding_combo = QtWidgets.QComboBox()
        self.encoding_combo.addItems(["utf-8", "latin-1", "cp1252"])
        self.encoding_combo.setCurrentText("utf-8")

        csv_layout.addWidget(QtWidgets.QLabel("Encoding:"), 1, 0)
        csv_layout.addWidget(self.encoding_combo, 1, 1)

        self.delimiter_edit = QtWidgets.QLineEdit(";")
        self.delimiter_edit.setFixedWidth(40)
        csv_layout.addWidget(QtWidgets.QLabel("Delimiter:"), 2, 0)
        csv_layout.addWidget(self.delimiter_edit, 2, 1)

        self.load_csv_btn = QtWidgets.QPushButton("Load CSV")
        csv_layout.addWidget(self.load_csv_btn, 3, 0, 1, 3)

        main_layout.addWidget(csv_group)

        # -------------------------------------------------
        # Sketch / guide lines
        # -------------------------------------------------
        sketch_group = QtWidgets.QGroupBox("Sketch & guide lines")
        sketch_layout = QtWidgets.QVBoxLayout(sketch_group)

        hl1 = QtWidgets.QHBoxLayout()
        self.sketch_combo = QtWidgets.QComboBox()
        hl1.addWidget(QtWidgets.QLabel("Sketch:"))
        hl1.addWidget(self.sketch_combo)
        self.scan_lines_btn = QtWidgets.QPushButton("Scan guide lines")
        hl1.addWidget(self.scan_lines_btn)
        sketch_layout.addLayout(hl1)

        self.lines_table = QtWidgets.QTableWidget()
        self.lines_table.setColumnCount(4)
        self.lines_table.setHorizontalHeaderLabels(
            ["Active", "Geo index", "Y", "CSV column"]
        )
        self.lines_table.horizontalHeader().setStretchLastSection(True)
        self.lines_table.setEditTriggers(QtWidgets.QAbstractItemView.AllEditTriggers)
        sketch_layout.addWidget(self.lines_table)

        main_layout.addWidget(sketch_group)

        # -------------------------------------------------
        # Text / extrusion / boolean / live preview
        # -------------------------------------------------
        geo_group = QtWidgets.QGroupBox("Text, extrusion & boolean")
        geo_layout = QtWidgets.QGridLayout(geo_group)

        # System fonts
        self.system_fonts = self._find_system_fonts()
        self.system_font_combo = QtWidgets.QComboBox()
        self.system_font_combo.addItem("– Choose system font –", "")
        for name, path in sorted(self.system_fonts.items()):
            self.system_font_combo.addItem(name, path)

        geo_layout.addWidget(QtWidgets.QLabel("System font:"), 0, 0)
        geo_layout.addWidget(self.system_font_combo, 0, 1, 1, 2)

        # Custom font file
        self.font_path_edit = QtWidgets.QLineEdit()
        self.font_browse_btn = QtWidgets.QPushButton("Choose font file…")

        geo_layout.addWidget(QtWidgets.QLabel("TTF/OTF file:"), 1, 0)
        geo_layout.addWidget(self.font_path_edit, 1, 1)
        geo_layout.addWidget(self.font_browse_btn, 1, 2)

        # FONT_SCALE
        self.font_scale_spin = QtWidgets.QDoubleSpinBox()
        self.font_scale_spin.setRange(0.05, 5.0)
        self.font_scale_spin.setSingleStep(0.05)
        self.font_scale_spin.setValue(0.7)

        geo_layout.addWidget(QtWidgets.QLabel("FONT_SCALE (relative height):"), 2, 0)
        geo_layout.addWidget(self.font_scale_spin, 2, 1)

        # Extrusion height
        self.extrude_height_spin = QtWidgets.QDoubleSpinBox()
        self.extrude_height_spin.setRange(0.01, 50.0)
        self.extrude_height_spin.setSingleStep(0.1)
        self.extrude_height_spin.setValue(1.0)

        geo_layout.addWidget(QtWidgets.QLabel("Extrusion height [mm]:"), 3, 0)
        geo_layout.addWidget(self.extrude_height_spin, 3, 1)

        # Boolean mode (final only)
        self.boolean_mode_combo = QtWidgets.QComboBox()
        self.boolean_mode_combo.addItems([
            "Generate text bodies only",
            "Fuse with target body"
        ])

        geo_layout.addWidget(QtWidgets.QLabel("Mode (final only):"), 4, 0)
        geo_layout.addWidget(self.boolean_mode_combo, 4, 1)

        self.target_body_combo = QtWidgets.QComboBox()
        geo_layout.addWidget(QtWidgets.QLabel("Target body (for fuse):"), 5, 0)
        geo_layout.addWidget(self.target_body_combo, 5, 1, 1, 2)

        # (moved) Live preview checkbox will be created near the navigator

        # Export format
        self.export_format_combo = QtWidgets.QComboBox()
        self.export_format_combo.addItem("STL", "stl")
        self.export_format_combo.addItem("3MF", "3mf")
        self.export_format_combo.addItem("STEP", "step")

        geo_layout.addWidget(QtWidgets.QLabel("Export format:"), 7, 0)
        geo_layout.addWidget(self.export_format_combo, 7, 1)

        main_layout.addWidget(geo_group)

        # -------------------------------------------------
        # CSV preview navigator (row selector)
        # -------------------------------------------------
        nav_h = QtWidgets.QHBoxLayout()
        self.prev_row_btn = QtWidgets.QPushButton("◀")
        self.next_row_btn = QtWidgets.QPushButton("▶")
        self.row_spin = QtWidgets.QSpinBox()
        self.row_spin.setMinimum(1)
        self.row_spin.setMaximum(1)
        self.row_spin.setValue(1)
        self.row_spin.setEnabled(False)

        nav_h.addStretch()
        nav_h.addWidget(self.prev_row_btn)
        nav_h.addWidget(self.row_spin)
        nav_h.addWidget(self.next_row_btn)
        nav_h.addStretch()

        # CSV data
        self.csv_headers = []
        self.csv_rows = []
        # preview row index (0-based)
        self.preview_row = 0

        # Populate UI initially
        self.populate_sketches()
        self.populate_bodies()

        # Connect signals
        self.csv_browse_btn.clicked.connect(self.on_browse_csv)
        self.load_csv_btn.clicked.connect(self.on_load_csv)
        self.scan_lines_btn.clicked.connect(self.on_scan_lines)
        self.font_browse_btn.clicked.connect(self.on_browse_font)
        self.system_font_combo.currentIndexChanged.connect(self.on_system_font_changed)
        self.sketch_combo.currentIndexChanged.connect(self.maybe_trigger_preview)
        self.font_scale_spin.valueChanged.connect(self.maybe_trigger_preview)
        self.extrude_height_spin.valueChanged.connect(self.maybe_trigger_preview)
        

        # Create preview/adopt checkboxes above navigator
        preview_h2 = QtWidgets.QHBoxLayout()
        self.preview_check = QtWidgets.QCheckBox("Live Preview")
        self.preview_check.setChecked(True)
        self.adopt_check = QtWidgets.QCheckBox("Adopt preview as object")

        # small info button with tooltip explaining adopt behavior
        info_btn = QtWidgets.QToolButton()
        try:
            info_icon = self.form.style().standardIcon(QtWidgets.QStyle.SP_MessageBoxInformation)
            info_btn.setIcon(info_icon)
        except Exception:
            info_btn.setText("i")
        info_btn.setAutoRaise(True)
        info_btn.setToolTip(
            "When checked, the currently selected preview row will be created\n"
            "as persistent editable objects when you press OK. No export will be performed."
        )

        preview_h2.addStretch()
        preview_h2.addWidget(self.preview_check)
        preview_h2.addWidget(self.adopt_check)
        preview_h2.addWidget(info_btn)
        preview_h2.addStretch()

        main_layout.addLayout(preview_h2)

        # Now add the navigator under the preview controls
        main_layout.addLayout(nav_h)

        # Connect preview/adopt signals
        self.preview_check.stateChanged.connect(self.maybe_trigger_preview)
        self.adopt_check.stateChanged.connect(self.on_adopt_changed)
        # Navigator signals
        self.prev_row_btn.clicked.connect(self.on_prev_row)
        self.next_row_btn.clicked.connect(self.on_next_row)
        self.row_spin.valueChanged.connect(self.on_row_changed)

    # ---------- TaskPanel API ----------

    def getStandardButtons(self):
        return int(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)

    def accept(self):
        """OK button: run export but keep the task panel open."""
        try:
            # If adopt is checked, create persistent objects for the
            # currently selected preview row and skip export. Otherwise
            # run the normal export generation.
            adopt_performed = False
            try:
                if getattr(self, "adopt_check", None) and self.adopt_check.isChecked():
                    try:
                        self.doc.openTransaction("Adopt preview")
                        self._create_persistent_row(self.preview_row)
                        self.doc.commitTransaction()
                        self.doc.recompute()
                        adopt_performed = True
                    except Exception as e:
                        try:
                            self.doc.abortTransaction()
                        except Exception:
                            pass
                        App.Console.PrintError("Adopt error: %s\n" % e)
                else:
                    self.run_generation(preview=False)
            except Exception:
                pass

            # Close the task panel when adoption was performed
            if adopt_performed:
                try:
                    Gui.Control.closeDialog()
                except Exception:
                    pass
        except Exception as e:
            App.Console.PrintError("Error: %s\n" % e)
            QtWidgets.QMessageBox.critical(self.form, "Error", str(e))

    def reject(self):
        """Cancel button / X: clear preview objects and close the task panel."""
        # Remove any remaining preview objects
        if self.preview_objects:
            for obj in list(self.preview_objects):
                if obj in self.doc.Objects:
                    try:
                        self.doc.removeObject(obj.Name)
                    except Exception:
                        pass
            self.preview_objects = []
            self.doc.recompute()

        # Close the task panel cleanly via FreeCAD
        try:
            Gui.Control.closeDialog()
        except Exception:
            pass

    # ---------- System fonts ----------

    def _find_system_fonts(self):
        font_dirs = []

        if sys.platform.startswith("win"):
            win_dir = os.environ.get("WINDIR", r"C:\Windows")
            font_dirs.append(os.path.join(win_dir, "Fonts"))
        elif sys.platform == "darwin":
            font_dirs.extend([
                "/System/Library/Fonts",
                "/Library/Fonts",
                os.path.expanduser("~/Library/Fonts"),
            ])
        else:
            font_dirs.extend([
                "/usr/share/fonts",
                "/usr/local/share/fonts",
                os.path.expanduser("~/.fonts"),
                os.path.expanduser("~/.local/share/fonts"),
            ])

        fonts = {}
        for d in font_dirs:
            if not os.path.isdir(d):
                continue
            for ext in ("*.ttf", "*.TTF", "*.otf", "*.OTF"):
                pattern = os.path.join(d, ext)
                for path in glob.glob(pattern):
                    name = os.path.basename(path)
                    fonts[name] = path

        return fonts

    def on_system_font_changed(self, index):
        path = self.system_font_combo.itemData(index)
        if path:
            self.font_path_edit.setText(path)
            self.maybe_trigger_preview()

    # ---------- UI helpers ----------

    def populate_sketches(self):
        self.sketch_combo.clear()
        for obj in self.doc.Objects:
            if obj.TypeId == "Sketcher::SketchObject":
                self.sketch_combo.addItem(obj.Label, obj.Name)

    def populate_bodies(self):
        self.target_body_combo.clear()
        self.target_body_combo.addItem("<no target body>", "")
        for obj in self.doc.Objects:
            if hasattr(obj, "Shape") and obj.Shape.Volume > 0:
                self.target_body_combo.addItem(obj.Label, obj.Name)

    def on_browse_csv(self):
        fn, _ = QtWidgets.QFileDialog.getOpenFileName(
            self.form, "Choose CSV", "", "CSV files (*.csv);;All files (*)"
        )
        if fn:
            self.csv_path_edit.setText(fn)
            self.maybe_trigger_preview()

    def on_browse_font(self):
        fn, _ = QtWidgets.QFileDialog.getOpenFileName(
            self.form,
            "Choose TTF/OTF font",
            "",
            "Font files (*.ttf *.otf);;All files (*)"
        )
        if fn:
            self.system_font_combo.setCurrentIndex(0)
            self.font_path_edit.setText(fn)
            self.maybe_trigger_preview()

    def on_load_csv(self):
        path = self.csv_path_edit.text().strip()
        if not path or not os.path.isfile(path):
            QtWidgets.QMessageBox.warning(self.form, "Error", "CSV file not found.")
            return

        enc = self.encoding_combo.currentText()
        delim = self.delimiter_edit.text() or ";"

        try:
            with open(path, "r", encoding=enc, newline="") as f:
                reader = csv.DictReader(f, delimiter=delim)
                self.csv_rows = list(reader)
                self.csv_headers = reader.fieldnames or []
        except Exception as e:
            QtWidgets.QMessageBox.critical(self.form, "CSV error", str(e))
            return

        QtWidgets.QMessageBox.information(
            self.form,
            "CSV loaded",
            "Columns: %s\nRows: %d" % (self.csv_headers, len(self.csv_rows)),
        )

        for row in range(self.lines_table.rowCount()):
            combo = self.lines_table.cellWidget(row, 3)
            if isinstance(combo, QtWidgets.QComboBox):
                combo.clear()
                combo.addItems(self.csv_headers)

        # Update navigator spinbox to reflect loaded CSV
        total_rows = len(self.csv_rows)
        self.row_spin.setMaximum(max(1, total_rows))
        self.row_spin.setValue(1)
        self.row_spin.setEnabled(total_rows > 0)
        self.preview_row = 0

        self.maybe_trigger_preview()

    def on_scan_lines(self):
        if self.sketch_combo.currentIndex() < 0:
            QtWidgets.QMessageBox.warning(self.form, "Error", "No sketch selected.")
            return

        sketch_name = self.sketch_combo.currentData()
        sk = self.doc.getObject(sketch_name)
        if sk is None:
            QtWidgets.QMessageBox.warning(self.form, "Error", "Sketch object not found.")
            return

        geos = sk.Geometry

        lines = []
        for i, g in enumerate(geos):
            if hasattr(g, "StartPoint") and hasattr(g, "EndPoint"):
                if abs(g.StartPoint.y - g.EndPoint.y) < 1e-6:
                    lines.append((i, g))

        self.lines_table.setRowCount(0)

        for idx, (gi, g) in enumerate(lines):
            self.lines_table.insertRow(idx)

            chk = QtWidgets.QTableWidgetItem()
            chk.setFlags(QtCore.Qt.ItemIsUserCheckable | QtCore.Qt.ItemIsEnabled)
            chk.setCheckState(QtCore.Qt.Checked)
            self.lines_table.setItem(idx, 0, chk)

            it_idx = QtWidgets.QTableWidgetItem(str(gi))
            it_idx.setFlags(QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
            self.lines_table.setItem(idx, 1, it_idx)

            y_val = g.StartPoint.y
            it_y = QtWidgets.QTableWidgetItem("%.3f" % y_val)
            it_y.setFlags(QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
            self.lines_table.setItem(idx, 2, it_y)

            col_combo = QtWidgets.QComboBox()
            col_combo.addItems(self.csv_headers)
            col_combo.currentIndexChanged.connect(self.maybe_trigger_preview)
            self.lines_table.setCellWidget(idx, 3, col_combo)

        self.maybe_trigger_preview()

    def get_line_mappings(self):
        mappings = []
        rows = self.lines_table.rowCount()
        for r in range(rows):
            item_active = self.lines_table.item(r, 0)
            if not item_active or item_active.checkState() != QtCore.Qt.Checked:
                continue

            item_geo = self.lines_table.item(r, 1)
            item_y = self.lines_table.item(r, 2)
            col_combo = self.lines_table.cellWidget(r, 3)

            if not item_geo or not item_y or not col_combo:
                continue

            try:
                geo_index = int(item_geo.text())
                y_line = float(item_y.text())
            except ValueError:
                continue

            csv_col = col_combo.currentText()
            if not csv_col:
                continue

            mappings.append((geo_index, y_line, csv_col))

        return mappings

    def maybe_trigger_preview(self):
        if not self.preview_check.isChecked():
            return
        try:
            if not self.csv_rows or not self.csv_headers:
                return
            if self.sketch_combo.currentIndex() < 0:
                return
            if not self.font_path_edit.text().strip():
                return
            if not self.get_line_mappings():
                return
            self.run_generation(preview=True)
        except Exception as e:
            App.Console.PrintError("Preview error: %s\n" % e)

    # ---------- Row navigator callbacks ----------

    def on_prev_row(self):
        if not self.row_spin.isEnabled():
            return
        v = self.row_spin.value()
        if v > 1:
            self.row_spin.setValue(v - 1)

    def on_next_row(self):
        if not self.row_spin.isEnabled():
            return
        v = self.row_spin.value()
        if v < self.row_spin.maximum():
            self.row_spin.setValue(v + 1)

    def on_row_changed(self, value):
        # spinbox is 1-based, internal index is 0-based
        try:
            self.preview_row = max(0, min(value - 1, max(0, len(self.csv_rows) - 1)))
        except Exception:
            self.preview_row = 0
        self.maybe_trigger_preview()

    def on_adopt_changed(self, state):
        # Do not create or commit objects when toggling the adopt checkbox.
        # Adoption is performed only when the user confirms with OK.
        return

    # ---------- Export helpers ----------

    def _get_export_base(self, export_ext):
        """Determine export base directory/name and clean up old exports with the selected extension."""
        fc_path = self.doc.FileName
        if not fc_path:
            raise RuntimeError("The document is not saved yet. Please save it first.")

        base_dir = os.path.dirname(fc_path)
        fc_name = os.path.splitext(os.path.basename(fc_path))[0]

        export_dir = os.path.join(base_dir, fc_name)

        if not os.path.isdir(export_dir):
            os.makedirs(export_dir, exist_ok=True)
        else:
            # Remove old exports with the same extension
            ext = "." + export_ext.lower()
            for f in os.listdir(export_dir):
                if f.lower().endswith(ext):
                    try:
                        os.remove(os.path.join(export_dir, f))
                    except Exception:
                        pass

        return export_dir, fc_name

    def _sanitize_component(self, text, max_len=None):
        allowed = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-"
        res = "".join(c if c in allowed else "_" for c in text)
        if max_len and len(res) > max_len:
            res = res[:max_len]
        return res

    def _build_export_path(self, export_dir, fc_name, used_cols, row, export_ext):
        ext = "." + export_ext.lower()
        name_parts = [fc_name]
        for col in used_cols:
            val = (row.get(col) or "").strip()
            if not val:
                continue
            name_parts.append(self._sanitize_component(val))

        base_name = "_".join(name_parts)
        filename = base_name + ext
        full_path = os.path.join(export_dir, filename)

        if len(full_path) <= MAX_PATH_LEN:
            return full_path

        dir_part = export_dir
        reserve = len(dir_part) + 1 + len(ext)
        max_name_len = MAX_PATH_LEN - reserve
        if max_name_len < 1:
            max_name_len = 1

        base_name_short = base_name[:max_name_len]
        filename_short = base_name_short + ext
        full_path_short = os.path.join(dir_part, filename_short)
        return full_path_short

    # ---------- Main logic ----------

    def run_generation(self, preview=False):
        if not self.csv_rows or not self.csv_headers:
            raise RuntimeError("CSV is not loaded.")

        mappings = self.get_line_mappings()
        if not mappings:
            raise RuntimeError("No active guide line mappings defined.")

        font_file = self.font_path_edit.text().strip()
        if not font_file or not os.path.isfile(font_file):
            raise RuntimeError("Font file is not set or not found.")

        if self.sketch_combo.currentIndex() < 0:
            raise RuntimeError("No sketch selected.")

        sketch_name = self.sketch_combo.currentData()
        sk = self.doc.getObject(sketch_name)
        if sk is None:
            raise RuntimeError("Sketch object not found.")

        font_scale = float(self.font_scale_spin.value())
        extrude_h = float(self.extrude_height_spin.value())
        boolean_mode = self.boolean_mode_combo.currentIndex()
        target_body_name = self.target_body_combo.currentData()
        export_ext = self.export_format_combo.currentData() or "stl"

        # Remove existing preview objects before the final run
        if not preview and self.preview_objects:
            for obj in list(self.preview_objects):
                if obj in self.doc.Objects:
                    try:
                        self.doc.removeObject(obj.Name)
                    except Exception:
                        pass
            self.preview_objects = []
            self.doc.recompute()

        # Transaction for final run
        if not preview:
            self.doc.openTransaction("CSV2Objects_Export")

        # Export base
        if not preview:
            export_dir, fc_name = self._get_export_base(export_ext)
            used_cols = []
            for _, _, col in mappings:
                if col not in used_cols:
                    used_cols.append(col)
        else:
            export_dir, fc_name, used_cols = None, None, None

        # Original target body (copied per CSV row)
        orig_target_body = None
        if not preview and boolean_mode == 1:
            if not target_body_name:
                raise RuntimeError("Fuse mode selected, but no target body chosen.")
            orig_target_body = self.doc.getObject(target_body_name)
            if orig_target_body is None:
                raise RuntimeError("Target body not found.")

        bbox_sk = sk.Shape.BoundBox
        z_offset = float(bbox_sk.ZMin)

        geos = sk.Geometry
        y_vals = [m[1] for m in mappings]
        if len(y_vals) >= 2:
            y_top = max(y_vals)
            y_bottom = min(y_vals)
            vertical_height = abs(y_top - y_bottom)
        else:
            vertical_height = 10.0

        text_size = vertical_height * font_scale

        App.Console.PrintMessage(
            "font_scale=%.3f, text_size=%.3f, preview=%s\n"
            % (font_scale, text_size, preview)
        )

        # Remove old preview objects in preview mode
        if preview and self.preview_objects:
            for obj in list(self.preview_objects):
                if obj in self.doc.Objects:
                    try:
                        self.doc.removeObject(obj.Name)
                    except Exception:
                        pass
            self.preview_objects = []
            self.doc.recompute()

        def make_and_place_text(value, geo_index, y_line):
            g = geos[geo_index]
            x1 = g.StartPoint.x
            x2 = g.EndPoint.x
            x_center = 0.5 * (x1 + x2)

            if not value:
                return None

            ss = Draft.makeShapeString(
                String=value,
                FontFile=font_file,
                Size=text_size,
                Tracking=0
            )

            ss.Placement.Base = App.Vector(x1, y_line, z_offset)
            self.doc.recompute()

            bbox = ss.Shape.BoundBox
            width = float(bbox.XLength)
            ymid = 0.5 * (float(bbox.YMin) + float(bbox.YMax))

            ss.Placement.Base.x = x_center - width / 2.0
            dy = y_line - ymid
            ss.Placement.Base.y += dy

            self.doc.recompute()
            return ss

        def extrude_text(ss_obj):
            if ss_obj is None:
                return None
            ext = self.doc.addObject("Part::Extrusion", "TextExtrude")
            ext.Base = ss_obj
            ext.Dir = App.Vector(0, 0, extrude_h)
            ext.Solid = True
            ext.TaperAngle = 0
            self.doc.recompute()
            return ext

        if preview:
            # Use the selected preview row (self.preview_row, 0-based)
            try:
                idx = int(self.preview_row)
            except Exception:
                idx = 0
                self.preview_row = 0
            if idx < 0 or idx >= len(self.csv_rows):
                idx = 0
                self.preview_row = 0
                try:
                    self.row_spin.setValue(1)
                except Exception:
                    pass
            rows_to_process = [self.csv_rows[idx]]
        else:
            rows_to_process = self.csv_rows

        # Progress dialog only in final mode
        progress = None
        if not preview:
            total = len(rows_to_process)
            progress = QtWidgets.QProgressDialog(
                "Exporting…", "Cancel", 0, total
            )
            progress.setWindowModality(QtCore.Qt.WindowModal)
            progress.setMinimumDuration(0)

        for row_idx, row in enumerate(rows_to_process):
            # Update progress
            if progress is not None:
                progress.setValue(row_idx)
                progress.setLabelText(
                    f"Exporting {row_idx + 1} / {len(rows_to_process)}"
                )
                QtWidgets.QApplication.processEvents()
                if progress.wasCanceled():
                    break

            App.Console.PrintMessage(
                "CSV row %d (%s)\n" % (row_idx, "Preview" if preview else "Final")
            )
            new_extrudes = []

            for (geo_index, y_line, csv_col) in mappings:
                if csv_col not in row:
                    continue
                value = (row.get(csv_col) or "").strip()
                ss = make_and_place_text(value, geo_index, y_line)
                ext = extrude_text(ss)
                if ext:
                    new_extrudes.append(ext)
                    if preview:
                        self.preview_objects.extend([ss, ext])

            # Per-row fuse: create a dedicated copy of the target body for each CSV row
            if not preview and boolean_mode == 1 and orig_target_body is not None:
                base_copy = self.doc.copyObject(orig_target_body, True)
                current = base_copy
                for ext in new_extrudes:
                    fuse = self.doc.addObject("Part::Fuse", "TextFuse")
                    fuse.Base = current
                    fuse.Tool = ext
                    self.doc.recompute()
                    current.ViewObject.Visibility = False
                    current = fuse

                export_obj_list = [current]
            else:
                export_obj_list = new_extrudes

            if not preview and export_obj_list:
                export_path = self._build_export_path(export_dir, fc_name, used_cols, row, export_ext)

                if os.path.exists(export_path):
                    try:
                        os.remove(export_path)
                    except Exception:
                        pass

                try:
                    ext = export_ext.lower()

                    # STL and 3MF via Mesh.export, STEP and others via ImportGui.export
                    if ext in ("stl", "3mf"):
                        Mesh.export(export_obj_list, export_path)
                    else:
                        ImportGui.export(export_obj_list, export_path)

                    App.Console.PrintMessage("Exported: %s\n" % export_path)
                except Exception as e:
                    App.Console.PrintError(
                        "Export error (%s) for '%s': %s\n"
                        % (export_ext, export_path, e)
                    )

        # Finish the progress dialog
        if not preview and progress is not None:
            progress.setValue(len(rows_to_process))

        

        if not preview:
            QtWidgets.QMessageBox.information(
                self.form,
                "Done",
                "Text bodies were generated, extruded, and exported.\n"
                "Boolean fuse executed with target body when selected.",
            )
        else:
            App.Console.PrintMessage("Preview updated.\n")

        # After the final run discard model changes to restore the original state
        if not preview:
            try:
                self.doc.abortTransaction()
            except Exception:
                pass
            self.doc.recompute()

    def _create_persistent_row(self, row_idx):
        """Create persistent objects for the CSV row index (0-based).
        This is executed inside a transaction by the caller so Undo/Redo
        will work after commit.
        """
        if not self.csv_rows or not self.csv_headers:
            raise RuntimeError("CSV is not loaded.")

        mappings = self.get_line_mappings()
        if not mappings:
            raise RuntimeError("No active guide line mappings defined.")

        font_file = self.font_path_edit.text().strip()
        if not font_file or not os.path.isfile(font_file):
            raise RuntimeError("Font file is not set or not found.")

        if self.sketch_combo.currentIndex() < 0:
            raise RuntimeError("No sketch selected.")

        sketch_name = self.sketch_combo.currentData()
        sk = self.doc.getObject(sketch_name)
        if sk is None:
            raise RuntimeError("Sketch object not found.")

        font_scale = float(self.font_scale_spin.value())
        extrude_h = float(self.extrude_height_spin.value())

        bbox_sk = sk.Shape.BoundBox
        z_offset = float(bbox_sk.ZMin)

        geos = sk.Geometry
        y_vals = [m[1] for m in mappings]
        if len(y_vals) >= 2:
            y_top = max(y_vals)
            y_bottom = min(y_vals)
            vertical_height = abs(y_top - y_bottom)
        else:
            vertical_height = 10.0

        text_size = vertical_height * font_scale

        # validate index
        try:
            idx = int(row_idx)
        except Exception:
            idx = 0
        if idx < 0 or idx >= len(self.csv_rows):
            raise RuntimeError("Preview row index out of range")

        row = self.csv_rows[idx]

        created = []

        def make_and_place_text_local(value, geo_index, y_line):
            g = geos[geo_index]
            x1 = g.StartPoint.x
            x2 = g.EndPoint.x
            x_center = 0.5 * (x1 + x2)

            if not value:
                return None

            ss = Draft.makeShapeString(
                String=value,
                FontFile=font_file,
                Size=text_size,
                Tracking=0
            )

            ss.Placement.Base = App.Vector(x1, y_line, z_offset)
            self.doc.recompute()

            bbox = ss.Shape.BoundBox
            width = float(bbox.XLength)
            ymid = 0.5 * (float(bbox.YMin) + float(bbox.YMax))

            ss.Placement.Base.x = x_center - width / 2.0
            dy = y_line - ymid
            ss.Placement.Base.y += dy

            self.doc.recompute()
            return ss

        def extrude_text_local(ss_obj):
            if ss_obj is None:
                return None
            ext = self.doc.addObject("Part::Extrusion", "TextExtrude")
            ext.Base = ss_obj
            ext.Dir = App.Vector(0, 0, extrude_h)
            ext.Solid = True
            ext.TaperAngle = 0
            self.doc.recompute()
            return ext

        # create objects for the single row
        for (geo_index, y_line, csv_col) in mappings:
            if csv_col not in row:
                continue
            value = (row.get(csv_col) or "").strip()
            ss = make_and_place_text_local(value, geo_index, y_line)
            ext = extrude_text_local(ss)
            if ext:
                created.append(ss)
                created.append(ext)

        return created


def run_csv2objects_macro():
    if not App.GuiUp:
        App.Console.PrintError("CSV2Objects macro requires the FreeCAD GUI.\n")
        return
    try:
        panel = CSV2ObjectsTaskPanel()
        Gui.Control.showDialog(panel)
    except Exception as e:
        App.Console.PrintError("CSV2Objects: failed to open dialog: %s\n" % e)


# Run immediately when launched as a macro
run_csv2objects_macro()
